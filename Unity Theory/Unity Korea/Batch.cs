using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Unity_Theory.Unity_Korea
{
    internal class Batch
    {
        /*
        Draw Call

        CPU : 디지털 컨텐츠를 구성하는 데이터를 읽는다.

        GPU : 데이터를 토데고 컨텐츠를 그린다.

        CPU 가 GPU 에게 내가 읽은 데이터를 그리라고 명령하는 것을 Draw Call 이라 부른다.

        SetPass Call

        Command Buffer : CPU 가 GPU 에게 그리라고 명령을 내릴 때 딸려 보내는 데이터
        이 때 그래픽 계열( 마테리얼, 셰이더 등 )데이터 묶음을 SetPass Call 이라 부른다.

        이렇게 Draw Call 뿐만 아니라 그래픽을 구성하는 데이터를 함께 넘기는 것을 Batch 라 부른다.
         */

        /*
        Batch 컴포넌트 들
            Sprite Renderer
            Mesh Renderer
            Line Renderer
            Trail Renderer
            Particle System
         */

        /*
        Dynamic Batching

        Preferences : Core Render Pipeline
            추가 속성을 모두 본다.

        Project Settings : Quality
            랜더 파이프 라인 에셋에서 숨겨진 모든 속성을 찾아서 Dynamic Batching 을 선택한다.

        Dynamic Batching은 Unity에서 사용되는 그래픽 렌더링 기술 중 하나로, 게임 오브젝트를 렌더링할 때 런타임에 동적으로 배치하는 프로세스를 나타낸다. 
        이것은 게임 성능을 최적화하고 그래픽 렌더링 효율성을 향상시키는 데 도움이 된다.

        Dynamic Batching은 다음과 같은 원리로 작동한다.

        비슷한 속성을 가진 오브젝트 배치: 동적 배치는 동일한 재질(머터리얼) 및 텍스쳐를 가진 게임 오브젝트를 찾아내고 이러한 오브젝트들을 단일 배치로 결합한다. 
        이는 같은 그래픽 요소들을 하나로 묶어서 처리하므로 성능을 향상시킨다.

        버텍스 및 삼각형 병합: Dynamic Batching은 비슷한 게임 오브젝트들의 버텍스 및 삼각형 데이터를 결합하여 하나의 배치로 만든다. 
        이렇게 하면 중복된 그래픽 요소의 계산 및 렌더링이 줄어들어 GPU의 부하를 감소시킨다.

        Draw Call 최적화: Dynamic Batching을 사용하면 Draw Call의 수를 줄일 수 있다. 
        게임에서는 Draw Call이 GPU에게 렌더링 작업을 지시하는 명령이다. 
        Dynamic Batching을 통해 단일 Draw Call로 여러 게임 오브젝트를 처리할 수 있어 그래픽 처리 효율성이 향상된다.

        Dynamic Batching의 이점

        그래픽 성능 향상: 게임이 동시에 더 많은 오브젝트를 처리할 수 있어 높은 프레임 속도를 유지할 수 있다.
        메모리 절약: 중복 데이터를 줄여 메모리 사용량을 최적화
        렌더링 최적화: 최소한의 GPU 자원을 사용하여 게임 오브젝트를 효율적으로 렌더링
         */

        /*
        Static Batching
        
        게임 오브젝트의 스태틱한 (변하지 않는) 부분을 미리 계산하여 미리 빌드된 데이터로 변환하는 프로세스를 의미 
        이것은 게임을 실행할 때 동적 배치와는 달리 런타임에서가 아닌 게임 빌드 때 발생하며 정적인 오브젝트에 적용된다.

        Static Batching의 주요 특징 및 이점

        게임 빌드 시 최적화: Static Batching은 게임 빌드 프로세스에서 실행된다. 
        게임 오브젝트의 정적 부분(이동하지 않는 부분)을 결합하여 정적 배치로 변환한다. 
        이는 게임 실행 중에 추가적인 연산을 필요로하지 않고 미리 최적화된 상태로 게임이 시작된다.

        속도 및 성능 향상: Static Batching은 게임 시작 시 미리 계산되므로 런타임에서는 렌더링 프로세스가 빨라진다. 
        이로써 게임이 더 높은 프레임 속도로 실행될 가능성이 높아진다.

        메모리 최적화: Static Batching은 중복된 버텍스 및 삼각형 데이터를 제거하므로 메모리 사용량을 줄여준다. 
        이는 게임이 더 적은 메모리를 차지하도록 도와준다.

        Draw Call 최적화: Static Batching은 정적 배치를 생성하고 각 배치에 대한 단일 Draw Call을 생성한다. 
        이는 GPU에 렌더링 명령을 보내는 데 필요한 호출 수를 줄이며 그래픽 성능을 향상시킨다.

        적용 가능한 경우: Static Batching은 게임 오브젝트가 움직이지 않고 재질과 텍스쳐가 동일한 경우에 가장 효과적이다.
         */

        /*
        SRP Batching( Scriptable Render Pipeline )

        SRP는 Unity의 렌더링 파이프라인을 사용자 지정하고 최적화하기 위한 프레임워크를 제공한다. 
        이를 통해 게임 개발자는 자신만의 렌더링 파이프라인을 만들거나 Unity에서 제공하는 기본 렌더링 파이프라인을 수정할 수 있다. 
        SRP의 한 측면은 렌더링 배치에 관련되어 있으며 특히 다음과 같은 측면을 포함할 수 있다:

        SRP Batching: SRP는 렌더링 배치 프로세스를 사용자 지정할 수 있는 능력을 제공한다. 
        이것은 동일한 머티리얼 및 속성을 가진 게임 오브젝트를 동시에 처리하여 한 번의 그리기 호출로 렌더링할 수 있게 해준다.

        GPU 인스턴싱: SRP는 GPU 인스턴싱을 활용하여 여러 게임 오브젝트를 하나의 인스턴스화된 메쉬로 그릴 수 있다. 
        이것은 동일한 메쉬 및 머티리얼을 가진 다수의 오브젝트를 효율적으로 렌더링하는 데 사용된다.

        커스텀 셰이더: SRP는 커스텀 셰이더를 사용하여 게임의 렌더링을 제어할 수 있는 능력을 제공한다. 
        이를 통해 렌더링 과정을 정밀하게 제어하고 최적화할 수 있다.
         */

        /*
        GPU 인스턴싱(GPU Instancing) : 그래픽 처리 장치(GPU)에서 여러 개의 오브젝트를 하나의 메쉬로 효율적으로 그리는 렌더링 기술이다. 

        일반적으로 게임에서 많은 오브젝트가 동일한 메쉬와 머티리얼을 공유한다. 
        예를 들어, 동일한 종류의 나무, 돌, 잔디, 혹은 아이템 등은 모두 동일한 모델(메쉬)과 머티리얼을 사용할 수 있다. 
        그러나 각각의 오브젝트가 별도의 렌더링 호출로 처리되면 오버헤드가 발생하며 성능이 저하된다.

        여러 오브젝트가 동일한 메쉬와 머티리얼을 공유하더라도 각각의 오브젝트는 개별적으로 움직일 수 있고, 
        개별적인 프로퍼티(예: 위치, 회전, 크기)를 가질 수 있다. 
        게임 엔진은 이러한 다수의 오브젝트를 하나의 인스턴스화된 메쉬로 처리하고, GPU는 각 오브젝트의 고유한 위치 및 속성을 고려하여 효율적으로 렌더링한다.

        GPU 인스턴싱의 주요 이점

        성능 향상: 오브젝트가 하나의 메쉬로 그려질 때 그리기 호출 수가 크게 감소하므로 렌더링 성능이 향상된다. 
        이는 특히 수백 개 이상의 오브젝트를 다룰 때 두드러진니다.

        메모리 효율: 하나의 메쉬 및 머티리얼만 사용하기 때문에 메모리 사용량이 감소한다.

        동적 애니메이션: 각 인스턴스는 고유한 위치, 회전 및 크기 값을 가질 수 있으므로 동적 애니메이션 및 변환을 적용할 수 있다.

        유지 관리 편의성: 다수의 오브젝트가 동일한 리소스를 공유하므로 업데이트 및 유지 관리가 훨씬 용이해진다.
         */
    }
}
